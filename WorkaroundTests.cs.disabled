using System;
using System.Data;
using ServiceStack.DataAnnotations;
using ServiceStack.OrmLite;
using ServiceStack.OrmLite.DuckDb;
using Xunit;

namespace DuckDbOrmLite.Tests;

/// <summary>
/// Tests to verify if DuckDB 1.3.2 workarounds are still needed
/// Each test isolates a specific workaround to determine if it can be removed
/// </summary>
[Collection("Sequential")]  // Prevent parallel execution with other tests
public class WorkaroundTests : IDisposable
{
    private readonly OrmLiteConnectionFactory _dbFactory;
    private Action<IDbCommand>? _customBeforeExecFilter;
    private readonly Action<IDbCommand>? _originalBeforeExecFilter;

    public WorkaroundTests()
    {
        // Save the original filter to restore it later
        _originalBeforeExecFilter = OrmLiteConfig.BeforeExecFilter;
        _dbFactory = new DuckDbOrmLiteConnectionFactory("Data Source=:memory:");
    }

    private void SetupBeforeExecFilter(bool includeDecimalCasting = true, bool includePositionalConversion = true)
    {
        OrmLiteConfig.BeforeExecFilter = dbCmd =>
        {
            var sql = dbCmd.CommandText;

            foreach (System.Data.IDbDataParameter param in dbCmd.Parameters)
            {
                if (param.ParameterName.StartsWith("$"))
                {
                    var originalName = param.ParameterName;
                    var nameWithoutPrefix = param.ParameterName.Substring(1);

                    if (includePositionalConversion && int.TryParse(nameWithoutPrefix, out int index))
                    {
                        // Positional parameter: $0 -> $1, $1 -> $2 (DuckDB uses 1-based)
                        var newSqlParam = $"${index + 1}";
                        sql = sql.Replace(originalName, newSqlParam);
                        param.ParameterName = (index + 1).ToString();
                    }
                    else
                    {
                        // Named parameter (like $p0, $Id, $Name)
                        param.ParameterName = nameWithoutPrefix;
                    }

                    if (includeDecimalCasting && param.Value is decimal)
                    {
                        var sqlParamName = param.ParameterName.StartsWith("$") ? param.ParameterName : $"${param.ParameterName}";
                        if (!sqlParamName.Contains("::"))
                        {
                            sql = sql.Replace(sqlParamName, $"{sqlParamName}::DECIMAL(38,12)");
                        }
                    }
                }
            }

            dbCmd.CommandText = sql;
            Console.WriteLine($"SQL: {dbCmd.CommandText}");
            Console.WriteLine($"PARAMS: {string.Join(", ", dbCmd.Parameters.Cast<IDbDataParameter>().Select(p => $"{p.ParameterName}={p.Value} (DbType:{p.DbType})"))}");

            _customBeforeExecFilter?.Invoke(dbCmd);
        };
    }

    public void Dispose()
    {
        // Restore the original filter instead of nulling it
        OrmLiteConfig.BeforeExecFilter = _originalBeforeExecFilter;
    }

    #region Test 1: Decimal Casting

    [Fact]
    public void Test_Decimal_Without_Explicit_Casting()
    {
        // Setup WITHOUT decimal casting
        SetupBeforeExecFilter(includeDecimalCasting: false);

        using var db = _dbFactory.Open();
        db.CreateTable<DecimalTest>(overwrite: true);

        var entity = new DecimalTest
        {
            Id = 1,
            Amount = 123.45m,
            Price = 99.99m
        };

        // Test INSERT with decimal
        db.Insert(entity);

        // Test SELECT with decimal parameter
        var result = db.Single<DecimalTest>(x => x.Amount == 123.45m);
        Assert.NotNull(result);
        Assert.Equal(123.45m, result.Amount);

        // Test UPDATE with decimal
        entity.Price = 199.99m;
        db.Update(entity);

        var updated = db.SingleById<DecimalTest>(1);
        Assert.Equal(199.99m, updated.Price);
    }

    [Fact]
    public void Test_Decimal_With_Explicit_Casting()
    {
        // Setup WITH decimal casting (current implementation)
        SetupBeforeExecFilter(includeDecimalCasting: true);

        using var db = _dbFactory.Open();
        db.CreateTable<DecimalTest>(overwrite: true);

        var entity = new DecimalTest
        {
            Id = 1,
            Amount = 123.45m,
            Price = 99.99m
        };

        db.Insert(entity);
        var result = db.Single<DecimalTest>(x => x.Amount == 123.45m);
        Assert.NotNull(result);
        Assert.Equal(123.45m, result.Amount);
    }

    #endregion

    #region Test 2: DbType.Currency Conversion

    [Fact]
    public void Test_Currency_DbType_Behavior()
    {
        SetupBeforeExecFilter(includeDecimalCasting: true);

        using var db = _dbFactory.Open();

        // Create a command with DbType.Currency
        var cmd = db.CreateCommand();
        var param = cmd.CreateParameter();
        param.ParameterName = "$amount";
        param.Value = 100.50m;
        param.DbType = DbType.Currency;
        cmd.Parameters.Add(param);

        // Check what DuckDB.NET does with Currency type
        Console.WriteLine($"Original DbType: {param.DbType}");

        // The dialect provider's InitQueryParam should convert it
        var provider = (DuckDbDialectProvider)db.GetDialectProvider();
        provider.InitQueryParam(param);

        Console.WriteLine($"After InitQueryParam DbType: {param.DbType}");
        Assert.Equal(DbType.Decimal, param.DbType);
    }

    #endregion

    #region Test 3: Named vs Positional Parameters in SqlExpression

    [Fact]
    public void Test_Named_Parameters_In_LINQ()
    {
        SetupBeforeExecFilter(includeDecimalCasting: true);

        using var db = _dbFactory.Open();
        db.CreateTable<DecimalTest>(overwrite: true);

        db.Insert(new DecimalTest { Id = 1, Amount = 100m, Price = 50m });
        db.Insert(new DecimalTest { Id = 2, Amount = 200m, Price = 150m });
        db.Insert(new DecimalTest { Id = 3, Amount = 300m, Price = 250m });

        // This uses SqlExpression with named parameters ($p0, $p1)
        var results = db.Select<DecimalTest>(x => x.Amount > 100m && x.Price < 200m);

        Assert.Single(results);
        Assert.Equal(2, results[0].Id);
    }

    #endregion

    #region Test Models

    private class DecimalTest
    {
        [PrimaryKey]
        public int Id { get; set; }

        public decimal Amount { get; set; }

        public decimal Price { get; set; }
    }

    #endregion
}
